<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
    <title>CS 240: Lab 3</title>
    <link href="lab3/hl-fine_blue.css" rel="stylesheet"/>
  </head>
  <body>
    <nav>
      <ul>
	<li><a href="../../index.html" class="material-icons">house</a></li>
	<li><a href="../../docs/index.html">Docs</a></li>
	<li><a href="../../exams-quizzes/index.html">Exams &amp; Quizzes</a></li>
	<li><a href="../../exercises/index.html">Exercises</a></li>
	<li><a href="../../hws/index.html">Homeworks</a></li>
	<li><a href="../../labs/index.html">Labs</a></li>
	<li><a href="../../misc/index.html">Misc</a></li>
	<li><a href="../../projects/index.html">Projects</a></li>
	<li><a href="../../slides/index.html">Slides</a></li>
      </ul>
    </nav>
    <div class="content">
      <section data-coord="lab3.umt:1:0"><h1 data-coord="lab3.umt:1:0">Lab 3</h1><p data-coord="lab3.umt:3:0"><strong data-coord="lab3.umt:3:0">Date</strong>: Feb 13, 2020
</p><p data-coord="lab3.umt:5:0">This document first describes the aims of this lab.  It then provides
necessary background.  It then describes the exercises which need to be
performed.
</p><p data-coord="lab3.umt:9:0">In the listings which follow, comments are any text extending from 
a <samp data-coord="lab3.umt:9:70">#</samp> character to end-of-line.
</p><section data-coord="lab3.umt:12:0"><h2 data-coord="lab3.umt:12:0">Aims</h2><p data-coord="lab3.umt:15:0">The aim of this lab is to introduce you to the C++ standard library.
After completing this lab, you should have some familiarity with the
following topics:
</p><ul data-coord="lab3.umt:19:0"><li data-coord="lab3.umt:19:0"><p data-coord="lab3.umt:19:4">The use of <samp data-coord="lab3.umt:19:15">std::string</samp>.
</p></li><li data-coord="lab3.umt:21:0"><p data-coord="lab3.umt:21:4">Use of sequence containers like <samp data-coord="lab3.umt:21:36">std::vector</samp>.
</p></li><li data-coord="lab3.umt:23:0"><p data-coord="lab3.umt:23:4">Use of associative containers like <samp data-coord="lab3.umt:23:39">std::map</samp>.
</p></li></ul></section><section data-coord="lab3.umt:25:0"><h2 data-coord="lab3.umt:25:0">Exercises</h2><p data-coord="lab3.umt:29:0">This lab has five exercises.  The first two provide motivation for
using <samp data-coord="lab3.umt:29:73">std::string</samp> which is used in the third exercise.  The fourth
exercise sorts numbers using a <samp data-coord="lab3.umt:29:167">std::vector</samp> which is a very popular
collection type in C++'s <strong data-coord="lab3.umt:29:230">Standard Template Library</strong> or STL.  The
final exercise uses vectors, maps and sets to allow querying
associations interactively.
</p><p data-coord="lab3.umt:36:0">Note that this lab provides you an <strong data-coord="lab3.umt:36:35">extremely limited</strong> glimpse into
the C++ standard library. Please make sure to check-out the references
and sources on the web to get a better idea of what it can do for you.
</p><section data-coord="lab3.umt:40:0"><h3 data-coord="lab3.umt:40:0">Starting up</h3><p data-coord="lab3.umt:43:0">Follow the <em data-coord="lab3.umt:43:44"><a href="../submission/submission.html" data-coord="lab3.umt:43:44">provided directions</a></em> for
starting up this lab in a new git <samp data-coord="lab3.umt:43:104">lab3</samp> branch and a new
<samp data-coord="lab3.umt:43:128">submit/lab3</samp> directory.  Start a <samp data-coord="lab3.umt:43:162">script</samp> session to log
your interaction into a <samp data-coord="lab3.umt:43:210">lab3.LOG</samp> file.
</p><p data-coord="lab3.umt:48:0">Copy all the lab3 exercises into your <samp data-coord="lab3.umt:48:38">submit/lab3</samp> directory by
copying the contents of the <samp data-coord="lab3.umt:48:93">~/cs240/labs/lab3/exercises</samp>:
</p><pre data-coord="lab3.umt:52:0">$ cd ~/i240?/submit/lab3
$ cp -r ~/cs240/labs/lab3/exercises .
</pre><p data-coord="lab3.umt:56:0">[Unlike the previous lab, we are copying the <samp data-coord="lab3.umt:56:45">exercises</samp> directory
rather than its sub-directories as the <samp data-coord="lab3.umt:56:106">exercises</samp> directory contains
a <samp data-coord="lab3.umt:56:139">data</samp> directory and a <samp data-coord="lab3.umt:56:162">Makefile</samp> used by multiple exercises.]
</p><p data-coord="lab3.umt:60:0">Add a <samp data-coord="lab3.umt:60:6">.gitignore</samp> file to the newly created <samp data-coord="lab3.umt:60:45">exercises</samp> directory
containing a single line <samp data-coord="lab3.umt:60:92">data</samp>.  This will prevent the
<samp data-coord="lab3.umt:60:123">exercises/data</samp> directory from being committed to your github
repository.
</p></section><section data-coord="lab3.umt:65:0"><h3 data-coord="lab3.umt:65:0">Exercise 1: A Buggy Program</h3><p data-coord="lab3.umt:68:0">Change over to the <samp data-coord="lab3.umt:68:19">./exercises/1-greet</samp> directory.
</p><pre data-coord="lab3.umt:71:0">$ cd exercises/1-greet
$ ls -l
</pre><p data-coord="lab3.umt:75:0">You should see that the directory contains a single <samp data-coord="lab3.umt:75:52">greet.cc</samp> file.
Read the README to see what the program is supposed to do.
</p><p data-coord="lab3.umt:78:0">Simply type <samp data-coord="lab3.umt:78:12">make -f ../Makefile</samp> in that directory to build the
program. The <samp data-coord="lab3.umt:78:78">-f</samp> option tells it to use a <samp data-coord="lab3.umt:78:108">Makefile</samp> other than
that in the current directory; in this case, we are using a <samp data-coord="lab3.umt:78:190">Makefile</samp>
from the parent directory.
</p><p data-coord="lab3.umt:83:0">It should compile a <samp data-coord="lab3.umt:83:20">greet</samp> executable without any errors or
warnings.  Now try to run it.  
</p><pre data-coord="lab3.umt:87:0">$ ./greet
usage: ./greet NAME...
$ ./greet bart lisa
</pre><p data-coord="lab3.umt:92:0">YMMV, but at different times when I ran this code I got either no
output or got the greeting lines printed out with strange characters.
</p><p data-coord="lab3.umt:95:0">Look at the code and the value which is returned by the <samp data-coord="lab3.umt:95:56">greetMsg()</samp>
function.  It is clearly a dangling pointer. In fact, it is so
obvious that even the compiler spots it and the <samp data-coord="lab3.umt:95:180">#pragma</samp> lines
have been inserted to turn off its warning.
</p><p data-coord="lab3.umt:100:0">We will fix the problem in the next exercise.
</p></section><section data-coord="lab3.umt:102:0"><h3 data-coord="lab3.umt:102:0">Exercise 2: Using new</h3><p data-coord="lab3.umt:105:0">Change over to the <samp data-coord="lab3.umt:105:19">./2-greet</samp> directory and type <samp data-coord="lab3.umt:105:50">make</samp>.
Another <samp data-coord="lab3.umt:105:66">greet</samp> program should be built without any problems.
</p><p data-coord="lab3.umt:108:0">This <samp data-coord="lab3.umt:108:5">greet</samp> program is very similar to the previous <samp data-coord="lab3.umt:108:53">greet</samp> program
except that instead of allocating the memory for the message on the
stack as in the previous exercise, the <samp data-coord="lab3.umt:108:176">greetMsg()</samp> allocates the
memory for the message on the heap using <samp data-coord="lab3.umt:108:244">new()</samp>.
</p><p data-coord="lab3.umt:113:0">Run the program for the same test cases as in the previous exercise.
It seems to run successfully.  But looks can be deceiving, does it
really run successfully?
</p><p data-coord="lab3.umt:117:0">Turns out it is leaking memory as the memory allocated using <samp data-coord="lab3.umt:117:61">new</samp>
is never <samp data-coord="lab3.umt:117:76">delete</samp>'d.  To verify this, run the program using
the memory debugger <samp data-coord="lab3.umt:117:147">valgrind</samp>:
</p><pre data-coord="lab3.umt:122:0">$ valgrind ./greet lisa bart
$
</pre><p data-coord="lab3.umt:126:0">You should see that it is indeed leaking memory.
</p><p data-coord="lab3.umt:128:0">Fix the problem by doing a <samp data-coord="lab3.umt:128:27">delete</samp> on the pointer returned
by <samp data-coord="lab3.umt:128:63">greetMsg()</samp> when you no longer need it.  Since the <samp data-coord="lab3.umt:128:115">new</samp>
allocated an array, C++ requires that you use something
like <samp data-coord="lab3.umt:128:182">delete[] msg</samp> where <samp data-coord="lab3.umt:128:203">msg</samp> is the return value from
<samp data-coord="lab3.umt:128:234">greetMsg()</samp>.
</p><p data-coord="lab3.umt:134:0">Run the program under valgrind once again to verify that you
have indeed fixed the memory leak.
</p><p data-coord="lab3.umt:137:0">An API like that provided by <samp data-coord="lab3.umt:137:29">greetMsg()</samp> is difficult to use because
the caller needs to be sure to free up the memory allocated for
the message when done with it.  In a large program, it can lead
to memory leaks or multiple <samp data-coord="lab3.umt:137:226">delete</samp>'s.  In the next exercise,
we will using <samp data-coord="lab3.umt:137:275">std::string</samp> from the C++ standard library
to solve this problem.
</p></section><section data-coord="lab3.umt:144:0"><h3 data-coord="lab3.umt:144:0">Exercise 3: Using std::string</h3><p data-coord="lab3.umt:147:0">The C++ language does not support a real string type since a <samp data-coord="lab3.umt:147:61">char *</samp>
pointer simply points to an array of bytes.  However, the library
supports a real string type which manages its own memory and provided
all the functionality one would expect from a string type.
</p><p data-coord="lab3.umt:152:0">Change over to the <samp data-coord="lab3.umt:152:19">./3-greet</samp> directory and look at the code in
<samp data-coord="lab3.umt:152:65">greet.cc</samp>.  Compile the program as in the previous exercises.
Run it using <samp data-coord="lab3.umt:152:141">./greet bart lisa</samp>.  It does not run quite right.
</p><p data-coord="lab3.umt:156:0">Look at the code for <samp data-coord="lab3.umt:156:21">greetMsg()</samp>.  It contains the line
</p><pre><span class="hl kwa">return</span> GREET <span class="hl opt">+</span> <span class="hl str">&apos; &apos;</span> <span class="hl opt">+</span> <span class="hl kwc">std</span><span class="hl opt">::</span><span class="hl kwd">string</span><span class="hl opt">(</span>name<span class="hl opt">);</span></pre><p data-coord="lab3.umt:162:0"><samp data-coord="lab3.umt:162:0">std::string</samp> overloads the <samp data-coord="lab3.umt:162:28">+</samp> operator to perform string concatenation and
the above line is an incorrect attempt to use it to concatenate <samp data-coord="lab3.umt:162:141">GREET</samp>,
a single space character and the <samp data-coord="lab3.umt:162:183">name</samp> parameter.
</p><p data-coord="lab3.umt:166:0">Since <samp data-coord="lab3.umt:166:6">+</samp> associates to the left, the above line is equivalent to
</p><pre><span class="hl kwa">return</span> <span class="hl opt">(</span>GREET <span class="hl opt">+</span> <span class="hl str">&apos; &apos;</span><span class="hl opt">) +</span> <span class="hl kwc">std</span><span class="hl opt">::</span><span class="hl kwd">string</span><span class="hl opt">(</span>name<span class="hl opt">);</span></pre><p data-coord="lab3.umt:172:0">Consider what the compiler sees as the operands for the first <samp data-coord="lab3.umt:172:62">+</samp>:
<samp data-coord="lab3.umt:172:67">GREET</samp> which is a <samp data-coord="lab3.umt:172:86">char *</samp> and <samp data-coord="lab3.umt:172:99">' '</samp> which is a <samp data-coord="lab3.umt:172:116">char</samp> which is an
integral type.  So it interprets the first <samp data-coord="lab3.umt:172:178">+</samp> as adding an integer to
a <samp data-coord="lab3.umt:172:208">char *</samp> pointer, resulting in a <samp data-coord="lab3.umt:172:241">char *</samp> pointer which is invalid.
</p><p data-coord="lab3.umt:177:0">Now when the compiler sees the second <samp data-coord="lab3.umt:177:38">+</samp>, the two operands are the
invalid <samp data-coord="lab3.umt:177:76">char *</samp> pointer and a <samp data-coord="lab3.umt:177:99">std::string</samp>.  Presumably
<samp data-coord="lab3.umt:177:126">std::string</samp> has set things up so that addition of a <samp data-coord="lab3.umt:177:180">char *</samp> with
a <samp data-coord="lab3.umt:177:196">std::string</samp> results in concatenation.  However, in this case,
the invalid <samp data-coord="lab3.umt:177:272">char *</samp> pointer is pointing to some memory which gets
treated as a C string by the overloaded <samp data-coord="lab3.umt:177:367">+</samp>.  This explains the
strange output you may have seen.
</p><p data-coord="lab3.umt:185:0">The fix is to set things up so that the first <samp data-coord="lab3.umt:185:46">+</samp> can match
the  overloaded <samp data-coord="lab3.umt:185:76">std::string</samp> <samp data-coord="lab3.umt:185:90">+</samp> operator.  This can be done
by simply converting its first operand to a <samp data-coord="lab3.umt:185:166">std::string</samp>.
</p><ol data-coord="lab3.umt:189:0"><li data-coord="lab3.umt:189:0"><p data-coord="lab3.umt:189:4">Make the necessary changes and run the code.  Verify that it is
now working correctly.
</p></li><li data-coord="lab3.umt:192:0"><p data-coord="lab3.umt:192:4">Run the program under valgrind and verify that it is not leaking
memory.
</p></li><li data-coord="lab3.umt:195:0"><p data-coord="lab3.umt:195:4">Print out the size of the return value from <samp data-coord="lab3.umt:195:48">greetMsg()</samp> using
<samp data-coord="lab3.umt:195:71">sizeof()</samp>.  Provide really long names to the program, you should
see that the size of the return value does not change.
</p></li></ol><p data-coord="lab3.umt:199:0">The fact that the size of the return value does not change means that
the <samp data-coord="lab3.umt:199:74">std::string</samp> return value is simply some kind of header with the
actual string content stored elsewhere, namely on the heap.  The fact
that the program does not leak memory even though there are no
explicit calls to <samp data-coord="lab3.umt:199:291">delete</samp> means that <samp data-coord="lab3.umt:199:311">std::string</samp> must be using some
kind of smart pointer behind the scenes to ensure that all memory is
freed up without any involvement by the user of <samp data-coord="lab3.umt:199:461">std::string</samp>.
</p></section><section data-coord="lab3.umt:207:0"><h3 data-coord="lab3.umt:207:0">Exercise 4: Using std::vector</h3><p data-coord="lab3.umt:210:0">Change over to the <samp data-coord="lab3.umt:210:19">./exercises/4-sortnums</samp> directory and look at the
code in <samp data-coord="lab3.umt:210:78">sortnums.cc</samp>.  It is set up to read <samp data-coord="lab3.umt:210:115">int</samp>'s from the files
specified by its command-line arguments into a dynamically grown
<samp data-coord="lab3.umt:210:203">std::vector</samp>, sort that vector and write out the results of
the sorted vector on standard output.
</p><ol data-coord="lab3.umt:216:0"><li data-coord="lab3.umt:216:0"><p data-coord="lab3.umt:216:4">The reading of the <samp data-coord="lab3.umt:216:23">int</samp>'s is handled by <samp data-coord="lab3.umt:216:45">readNums()</samp>. It's
operation should be quite clear from the code; it uses the <samp data-coord="lab3.umt:216:127">&gt;&gt;</samp>
<samp data-coord="lab3.umt:216:136">istream</samp> operator to read the next <samp data-coord="lab3.umt:216:172">int</samp> from <samp data-coord="lab3.umt:216:183">istream</samp> <samp data-coord="lab3.umt:216:193">in</samp> and
adds it the the vector using its <samp data-coord="lab3.umt:216:239">push_back()</samp> operation.
</p></li><li data-coord="lab3.umt:221:0"><p data-coord="lab3.umt:221:4">Once <samp data-coord="lab3.umt:221:9">readNums()</samp> returns to <samp data-coord="lab3.umt:221:33">main()</samp>, <samp data-coord="lab3.umt:221:43">main()</samp> sorts the returned
vector using the <samp data-coord="lab3.umt:221:92">sort()</samp> function provided by the <samp data-coord="lab3.umt:221:126">algorithm</samp>
header file.  To understand its operation, please look at its
<a href="https://en.cppreference.com/w/cpp/algorithm/sort" data-coord="lab3.umt:221:260">documentation.</a>
You will see multiple overloaded <samp data-coord="lab3.umt:221:312">sort()</samp> headers for different
versions of C++.  Basically, <samp data-coord="lab3.umt:221:376">sort()</samp> takes two "pointers"
pointing to the start of the sequence to be sorted and one beyond
the end of the sequence.  That sequence should allow "random
iteration" meaning it is easy to jump back-and-forth within the
sequence.  So the code in <samp data-coord="lab3.umt:221:641">main()</samp> sorts the <samp data-coord="lab3.umt:221:660">nums</samp> vector by
specifying the start of the iterator as <samp data-coord="lab3.umt:221:721">nums.begin()</samp> and the
end of the iterator as <samp data-coord="lab3.umt:221:771">nums.end()</samp>.
</p><p data-coord="lab3.umt:234:4">[Many STL containers provide similar <samp data-coord="lab3.umt:234:41">begin()</samp> and <samp data-coord="lab3.umt:234:55">end()</samp>
iterators.]
</p><p data-coord="lab3.umt:237:4">No comparison function is provided to <samp data-coord="lab3.umt:237:42">sort()</samp> in our code.  So
<samp data-coord="lab3.umt:237:72">sort()</samp> will simply use the default ordering of the data type
stored in the vector.  In our case, we are storing <samp data-coord="lab3.umt:237:190">int</samp>'s, so the
ordering used is <samp data-coord="lab3.umt:237:227">&lt;=</samp> on <samp data-coord="lab3.umt:237:235">int</samp>'s.
</p></li><li data-coord="lab3.umt:242:0"><p data-coord="lab3.umt:242:4">The <samp data-coord="lab3.umt:242:8">sort()</samp> is followed by a single line loop which outputs
the <samp data-coord="lab3.umt:242:73">int</samp>'s from the sorted <samp data-coord="lab3.umt:242:97">nums</samp> on to standard output.
</p></li></ol><p data-coord="lab3.umt:245:0">Compile and run the code.  There are a couple of small data files
in this directory:
</p><pre>$ sortnums <span class="hl opt">*</span>.dat</pre><p data-coord="lab3.umt:253:0">Modify the provided code so as to change the <samp data-coord="lab3.umt:253:45">sort()</samp> to sort in
non-ascending order.  According to the
<a href="https://en.cppreference.com/w/cpp/algorithm/sort" data-coord="lab3.umt:253:156">documentation,</a> you
will need to provide a comparison function as the third argument to
the <samp data-coord="lab3.umt:253:247">sort()</samp> function.  This comparison function <samp data-coord="lab3.umt:253:292">comp()</samp> should
return true if its first argument is less than (i.e. ordered <em data-coord="lab3.umt:253:369">before</em>)
the second.  Its signature should be:
</p><pre><span class="hl kwb">bool</span> <span class="hl kwd">cmp</span><span class="hl opt">(</span><span class="hl kwb">const int</span> <span class="hl opt">&amp;</span>a<span class="hl opt">,</span> <span class="hl kwb">const int</span> <span class="hl opt">&amp;</span>b<span class="hl opt">);</span></pre><p data-coord="lab3.umt:265:0">Write this comparison function, and retest to verify that your output
now uses the reverse order.
</p></section><section data-coord="lab3.umt:268:0"><h3 data-coord="lab3.umt:268:0">Exercise 5: Mapping Numbers to Paths</h3><p data-coord="lab3.umt:271:0">Change over to the <samp data-coord="lab3.umt:271:19">./exercises/5-numpaths</samp> directory.  The program
in file <samp data-coord="lab3.umt:271:76">numpaths.cc</samp> reads in <samp data-coord="lab3.umt:271:99">int</samp>'s from the files specified
by one-or-more command-line arguments.  It sets up an association
between each number and the file(s) which contain it.  It then
enters an interactive loop where it reads an <samp data-coord="lab3.umt:271:306">int</samp> from the
input and outputs the names of all the files which contain
it.
</p><p data-coord="lab3.umt:279:0">Compile and run the program:
</p><pre>$ <span class="hl kwc">make</span> <span class="hl kwb">-f</span> ..<span class="hl opt">/</span>Makefile
$ numpaths ..<span class="hl opt">/</span>data<span class="hl opt">/*</span>.dat
<span class="hl opt">&gt;&gt;</span> <span class="hl num">342</span>
<span class="hl num">342</span><span class="hl opt">:</span> ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">4</span>.dat ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">8</span>.dat 
<span class="hl opt">&gt;&gt;</span> <span class="hl num">324</span>
<span class="hl num">324</span><span class="hl opt">:</span> ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">1</span>.dat ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">3</span>.dat ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">8</span>.dat 
<span class="hl opt">&gt;&gt;</span> <span class="hl num">45</span>
<span class="hl num">45</span><span class="hl opt">:</span> NOT FOUND
<span class="hl opt">&gt;&gt;</span> <span class="hl num">234</span>
<span class="hl num">234</span><span class="hl opt">:</span> ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">6</span>.dat ..<span class="hl opt">/</span>data<span class="hl opt">/</span><span class="hl num">8</span>.dat 
<span class="hl opt">&gt;&gt;</span> <span class="hl slc">#type ^D for EOF</span>
$</pre><p data-coord="lab3.umt:297:0">We essentially need a mapping between each <samp data-coord="lab3.umt:297:43">int</samp> and the collection
of filenames of the files which contain that <samp data-coord="lab3.umt:297:113">int</samp>.  Since the
same <samp data-coord="lab3.umt:297:136">int</samp> can occur in the same file multiple times, we would
like to avoid duplicate filenames.  We can avoid duplicates
by using a <samp data-coord="lab3.umt:297:265">set</samp> to represent the collection of filenames.
</p><p data-coord="lab3.umt:303:0">So our basic data-structure will be a map from <samp data-coord="lab3.umt:303:47">int</samp>'s to
a set of strings representing filenames.  In C++ template
notation, we write this map as <samp data-coord="lab3.umt:303:147">map&lt;int, set&lt;string&gt;&gt;</samp>.
</p><p data-coord="lab3.umt:307:0">A few points are worth noting:
</p><ul data-coord="lab3.umt:309:0"><li data-coord="lab3.umt:309:0"><p data-coord="lab3.umt:309:4">When filling in the map in the <samp data-coord="lab3.umt:309:35">readNums()</samp> function, we do so
using its overloaded <samp data-coord="lab3.umt:309:92">[]</samp> operator.  This has the happy
side-effect that if do a lookup of <samp data-coord="lab3.umt:309:166">map[n]</samp> when <samp data-coord="lab3.umt:309:180">n</samp> has not been
seen earlier, then the <samp data-coord="lab3.umt:309:224">map</samp> will create a new slot in the map
initialized to an empty set and return a <strong data-coord="lab3.umt:309:309">reference</strong> to the new
set.  Hence the <samp data-coord="lab3.umt:309:352">insert()</samp> on the returned set will add in the
corresponding filename.
</p></li><li data-coord="lab3.umt:317:0"><p data-coord="lab3.umt:317:4">When we are querying the map in the interactive loop, we do not
want a query for a non-existent <samp data-coord="lab3.umt:317:104">int</samp> to create a new slot in the
map.  So we do not use the <samp data-coord="lab3.umt:317:169">[]</samp> operator; instead we use the
<samp data-coord="lab3.umt:317:207">map</samp>'s <samp data-coord="lab3.umt:317:215">at()</samp> member function which throws an exception when the
<samp data-coord="lab3.umt:317:277">int</samp> does not exist.
</p></li></ul><p data-coord="lab3.umt:323:0">Having read and understood the program, modify it so that instead of
mapping <samp data-coord="lab3.umt:323:77">int</samp>'s to filenames, it maps each filename to the sum of the
<samp data-coord="lab3.umt:323:139">int</samp>'s in that file.  Change the interactive loop to allow the user
to type in a filename (which in general will be a path).  If the filename
is known to your program, it should print out the sum of all the
<samp data-coord="lab3.umt:323:347">int</samp>'s in that file.
</p></section><section data-coord="lab3.umt:331:0"><h3 data-coord="lab3.umt:331:0">Winding Up</h3><p data-coord="lab3.umt:334:0">Follow the <em data-coord="lab3.umt:334:44"><a href="../submission/submission.html" data-coord="lab3.umt:334:44">provided directions</a></em> for
winding up this lab. Terminate your <samp data-coord="lab3.umt:334:106">script</samp> session producing the log
file <samp data-coord="lab3.umt:334:146">lab3.LOG</samp> in your <samp data-coord="lab3.umt:334:165">lab3</samp> directory.  Add all your files to
git and commit.  Then merge your <samp data-coord="lab3.umt:334:239">lab3</samp> branch into the <samp data-coord="lab3.umt:334:262">master</samp>
branch and commit your changes.
</p></section></section><section data-coord="lab3.umt:340:0"><h2 data-coord="lab3.umt:340:0">References</h2><p data-coord="lab3.umt:343:0">Online <em data-coord="lab3.umt:343:41"><a href="https://en.cppreference.com/w/" data-coord="lab3.umt:343:41">&lt;https://en.cppreference.com/w/&gt;</a></em>.
</p><p data-coord="lab3.umt:345:0">Nicolai M. Josuttis, <em data-coord="lab3.umt:345:21">The C++ Standard Library: A Tutorial and
Reference</em>, 2nd Edition, Addison-Wesley, 2012.
</p><p data-coord="lab3.umt:348:0">Scott Meyers, <em data-coord="lab3.umt:348:14">Effective STL: 50 Specific Ways to Improve Your Use of
the Standard Template Library</em>, Addison-Wesley, 2001.
</p></section></section>
    </div> <!-- #content -->
  </body>
</html>
